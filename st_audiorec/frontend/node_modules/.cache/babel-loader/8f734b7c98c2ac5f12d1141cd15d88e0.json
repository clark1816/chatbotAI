{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Data } from '../data';\nimport { Vector } from '../vector';\nimport { BaseVector } from './base';\nimport { vectorFromValuesWithType } from './index';\nimport { Float16, Float32, Float64 } from '../type';\n/** @ignore */\n\nexport class FloatVector extends BaseVector {\n  /** @nocollapse */\n  static from(input) {\n    let ArrowType = vectorTypeToDataType(this);\n\n    if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\n      let InputType = arrayTypeToDataType(input.constructor) || ArrowType; // Special case, infer the Arrow DataType from the input if calling the base\n      // FloatVector.from with a TypedArray, e.g. `FloatVector.from(new Float32Array())`\n\n      if (ArrowType === null) {\n        ArrowType = InputType;\n      } // If the DataType inferred from the Vector constructor matches the\n      // DataType inferred from the input arguments, return zero-copy view\n\n\n      if (ArrowType && ArrowType === InputType) {\n        let type = new ArrowType();\n        let length = input.byteLength / type.ArrayType.BYTES_PER_ELEMENT; // If the ArrowType is Float16 but the input type isn't a Uint16Array,\n        // let the Float16Builder handle casting the input values to Uint16s.\n\n        if (!convertTo16Bit(ArrowType, input.constructor)) {\n          return Vector.new(Data.Float(type, 0, length, 0, null, input));\n        }\n      }\n    }\n\n    if (ArrowType) {\n      // If the DataType inferred from the Vector constructor is different than\n      // the DataType inferred from the input TypedArray, or if input isn't a\n      // TypedArray, use the Builders to construct the result Vector\n      return vectorFromValuesWithType(() => new ArrowType(), input);\n    }\n\n    if (input instanceof DataView || input instanceof ArrayBuffer) {\n      throw new TypeError(`Cannot infer float type from instance of ${input.constructor.name}`);\n    }\n\n    throw new TypeError('Unrecognized FloatVector input');\n  }\n\n}\n/** @ignore */\n\nexport class Float16Vector extends FloatVector {\n  // Since JS doesn't have half floats, `toArray()` returns a zero-copy slice\n  // of the underlying Uint16Array data. This behavior ensures we don't incur\n  // extra compute or copies if you're calling `toArray()` in order to create\n  // a buffer for something like WebGL. Buf if you're using JS and want typed\n  // arrays of 4-to-8-byte precision, these methods will enumerate the values\n  // and clamp to the desired byte lengths.\n  toFloat32Array() {\n    return new Float32Array(this);\n  }\n\n  toFloat64Array() {\n    return new Float64Array(this);\n  }\n\n}\n/** @ignore */\n\nexport class Float32Vector extends FloatVector {}\n/** @ignore */\n\nexport class Float64Vector extends FloatVector {}\n\nconst convertTo16Bit = (typeCtor, dataCtor) => {\n  return typeCtor === Float16 && dataCtor !== Uint16Array;\n};\n/** @ignore */\n\n\nconst arrayTypeToDataType = ctor => {\n  switch (ctor) {\n    case Uint16Array:\n      return Float16;\n\n    case Float32Array:\n      return Float32;\n\n    case Float64Array:\n      return Float64;\n\n    default:\n      return null;\n  }\n};\n/** @ignore */\n\n\nconst vectorTypeToDataType = ctor => {\n  switch (ctor) {\n    case Float16Vector:\n      return Float16;\n\n    case Float32Vector:\n      return Float32;\n\n    case Float64Vector:\n      return Float64;\n\n    default:\n      return null;\n  }\n};","map":{"version":3,"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,IAAT,QAAqB,SAArB;AACA,SAASC,MAAT,QAAuB,WAAvB;AAEA,SAASC,UAAT,QAA2B,QAA3B;AAEA,SAASC,wBAAT,QAAyC,SAAzC;AAEA,SAAgBC,OAAhB,EAAyBC,OAAzB,EAAkCC,OAAlC,QAA6D,SAA7D;AAqBA;;AACA,OAAM,MAAOC,WAAP,SAAoDL,UAApD,CAAiE;AAkBnE;AACkB,SAAJM,IAAI,CAA8DC,KAA9D,EAAwF;AAEtG,QAAIC,SAAS,GAAGC,oBAAoB,CAAC,IAAD,CAApC;;AAEA,QAAKF,KAAK,YAAYG,WAAlB,IAAkCA,WAAW,CAACC,MAAZ,CAAmBJ,KAAnB,CAAtC,EAAiE;AAC7D,UAAIK,SAAS,GAAGC,mBAAmB,CAACN,KAAK,CAACO,WAAP,CAAnB,IAA4DN,SAA5E,CAD6D,CAE7D;AACA;;AACA,UAAIA,SAAS,KAAK,IAAlB,EAAwB;AACpBA,iBAAS,GAAGI,SAAZ;AACH,OAN4D,CAO7D;AACA;;;AACA,UAAIJ,SAAS,IAAIA,SAAS,KAAKI,SAA/B,EAA0C;AACtC,YAAIG,IAAI,GAAG,IAAIP,SAAJ,EAAX;AACA,YAAIQ,MAAM,GAAGT,KAAK,CAACU,UAAN,GAAmBF,IAAI,CAACG,SAAL,CAAeC,iBAA/C,CAFsC,CAGtC;AACA;;AACA,YAAI,CAACC,cAAc,CAACZ,SAAD,EAAYD,KAAK,CAACO,WAAlB,CAAnB,EAAmD;AAC/C,iBAAOf,MAAM,CAACsB,GAAP,CAAWvB,IAAI,CAACwB,KAAL,CAAWP,IAAX,EAAiB,CAAjB,EAAoBC,MAApB,EAA4B,CAA5B,EAA+B,IAA/B,EAAqCT,KAArC,CAAX,CAAP;AACH;AACJ;AACJ;;AAED,QAAIC,SAAJ,EAAe;AACX;AACA;AACA;AACA,aAAOP,wBAAwB,CAAC,MAAM,IAAIO,SAAJ,EAAP,EAA8BD,KAA9B,CAA/B;AACH;;AAED,QAAKA,KAAK,YAAYgB,QAAlB,IAAgChB,KAAK,YAAYG,WAArD,EAAmE;AAC/D,YAAM,IAAIc,SAAJ,CAAc,4CAA4CjB,KAAK,CAACO,WAAN,CAAkBW,IAAI,EAAhF,CAAN;AACH;;AAED,UAAM,IAAID,SAAJ,CAAc,gCAAd,CAAN;AACH;;AAvDkE;AA0DvE;;AACA,OAAM,MAAOE,aAAP,SAA6BrB,WAA7B,CAAiD;AACnD;AACA;AACA;AACA;AACA;AACA;AACOsB,gBAAc;AAAK,WAAO,IAAIC,YAAJ,CAAiB,IAAjB,CAAP;AAAoD;;AACvEC,gBAAc;AAAK,WAAO,IAAIC,YAAJ,CAAiB,IAAjB,CAAP;AAAoD;;AAR3B;AAWvD;;AACA,OAAM,MAAOC,aAAP,SAA6B1B,WAA7B,CAAiD;AACvD;;AACA,OAAM,MAAO2B,aAAP,SAA6B3B,WAA7B,CAAiD;;AAEvD,MAAMe,cAAc,GAAG,CAACa,QAAD,EAAgBC,QAAhB,KAAiC;AACpD,SAAQD,QAAQ,KAAK/B,OAAd,IAA2BgC,QAAQ,KAAKC,WAA/C;AACH,CAFD;AAIA;;;AACA,MAAMtB,mBAAmB,GAAIuB,IAAD,IAAyB;AACjD,UAAQA,IAAR;AACI,SAAKD,WAAL;AAAqB,aAAOjC,OAAP;;AACrB,SAAK0B,YAAL;AAAqB,aAAOzB,OAAP;;AACrB,SAAK2B,YAAL;AAAqB,aAAO1B,OAAP;;AACrB;AAAS,aAAO,IAAP;AAJb;AAMH,CAPD;AASA;;;AACA,MAAMK,oBAAoB,GAAI2B,IAAD,IAAkC;AAC3D,UAAQA,IAAR;AACI,SAAKV,aAAL;AAAoB,aAAOxB,OAAP;;AACpB,SAAK6B,aAAL;AAAoB,aAAO5B,OAAP;;AACpB,SAAK6B,aAAL;AAAoB,aAAO5B,OAAP;;AACpB;AAAS,aAAO,IAAP;AAJb;AAMH,CAPD","names":["Data","Vector","BaseVector","vectorFromValuesWithType","Float16","Float32","Float64","FloatVector","from","input","ArrowType","vectorTypeToDataType","ArrayBuffer","isView","InputType","arrayTypeToDataType","constructor","type","length","byteLength","ArrayType","BYTES_PER_ELEMENT","convertTo16Bit","new","Float","DataView","TypeError","name","Float16Vector","toFloat32Array","Float32Array","toFloat64Array","Float64Array","Float32Vector","Float64Vector","typeCtor","dataCtor","Uint16Array","ctor"],"sources":["vector/float.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data';\nimport { Vector } from '../vector';\nimport { Chunked } from './chunked';\nimport { BaseVector } from './base';\nimport { VectorBuilderOptions } from './index';\nimport { vectorFromValuesWithType } from './index';\nimport { VectorBuilderOptionsAsync } from './index';\nimport { Float, Float16, Float32, Float64, FloatArray } from '../type';\nimport { VectorType as V, TypedArrayConstructor } from '../interfaces';\n\n/** @ignore */\ntype FloatVectorConstructors =\n    typeof FloatVector   |\n    typeof Float16Vector |\n    typeof Float32Vector |\n    typeof Float64Vector ;\n\n/** @ignore */\ntype FromInput<T extends Float, TNull = any> =\n    FloatArray                          |\n    Iterable<T['TValue'] | TNull>       |\n    AsyncIterable<T['TValue'] | TNull>  |\n    VectorBuilderOptions<T, TNull>      |\n    VectorBuilderOptionsAsync<T, TNull> ;\n\n/** @ignore */\ntype FloatArrayCtor = TypedArrayConstructor<FloatArray>;\n\n/** @ignore */\nexport class FloatVector<T extends Float = Float> extends BaseVector<T> {\n\n    // Guaranteed zero-copy variants\n    public static from(this: typeof FloatVector, input: Uint16Array): Float16Vector;\n    public static from(this: typeof FloatVector, input: Float32Array): Float32Vector;\n    public static from(this: typeof FloatVector, input: Float64Array): Float64Vector;\n\n    // Zero-copy if input is a TypedArray of the same type as the\n    // Vector that from is called on, otherwise uses the Builders\n    public static from<TNull = any>(this: typeof Float16Vector,  input: FromInput<Float16, TNull>): Float16Vector;\n    public static from<TNull = any>(this: typeof Float32Vector,  input: FromInput<Float32, TNull>): Float32Vector;\n    public static from<TNull = any>(this: typeof Float64Vector,  input: FromInput<Float64, TNull>): Float64Vector;\n\n    // Not zero-copy\n    public static from<T extends Float, TNull = any>(this: typeof FloatVector, input: Iterable<T['TValue'] | TNull>): V<T>;\n    public static from<T extends Float, TNull = any>(this: typeof FloatVector, input: AsyncIterable<T['TValue'] | TNull>): Promise<V<T>>;\n    public static from<T extends Float, TNull = any>(this: typeof FloatVector, input: VectorBuilderOptions<T, TNull>): Chunked<T>;\n    public static from<T extends Float, TNull = any>(this: typeof FloatVector, input: VectorBuilderOptionsAsync<T, TNull>): Promise<Chunked<T>>;\n    /** @nocollapse */\n    public static from<T extends Float, TNull = any>(this: FloatVectorConstructors, input: FromInput<T, TNull>) {\n\n        let ArrowType = vectorTypeToDataType(this);\n\n        if ((input instanceof ArrayBuffer) || ArrayBuffer.isView(input)) {\n            let InputType = arrayTypeToDataType(input.constructor as FloatArrayCtor) || ArrowType;\n            // Special case, infer the Arrow DataType from the input if calling the base\n            // FloatVector.from with a TypedArray, e.g. `FloatVector.from(new Float32Array())`\n            if (ArrowType === null) {\n                ArrowType = InputType;\n            }\n            // If the DataType inferred from the Vector constructor matches the\n            // DataType inferred from the input arguments, return zero-copy view\n            if (ArrowType && ArrowType === InputType) {\n                let type = new ArrowType();\n                let length = input.byteLength / type.ArrayType.BYTES_PER_ELEMENT;\n                // If the ArrowType is Float16 but the input type isn't a Uint16Array,\n                // let the Float16Builder handle casting the input values to Uint16s.\n                if (!convertTo16Bit(ArrowType, input.constructor)) {\n                    return Vector.new(Data.Float(type, 0, length, 0, null, input as FloatArray));\n                }\n            }\n        }\n\n        if (ArrowType) {\n            // If the DataType inferred from the Vector constructor is different than\n            // the DataType inferred from the input TypedArray, or if input isn't a\n            // TypedArray, use the Builders to construct the result Vector\n            return vectorFromValuesWithType(() => new ArrowType!() as T, input);\n        }\n\n        if ((input instanceof DataView) || (input instanceof ArrayBuffer)) {\n            throw new TypeError(`Cannot infer float type from instance of ${input.constructor.name}`);\n        }\n\n        throw new TypeError('Unrecognized FloatVector input');\n    }\n}\n\n/** @ignore */\nexport class Float16Vector extends FloatVector<Float16> {\n    // Since JS doesn't have half floats, `toArray()` returns a zero-copy slice\n    // of the underlying Uint16Array data. This behavior ensures we don't incur\n    // extra compute or copies if you're calling `toArray()` in order to create\n    // a buffer for something like WebGL. Buf if you're using JS and want typed\n    // arrays of 4-to-8-byte precision, these methods will enumerate the values\n    // and clamp to the desired byte lengths.\n    public toFloat32Array() { return new Float32Array(this as Iterable<number>); }\n    public toFloat64Array() { return new Float64Array(this as Iterable<number>); }\n}\n\n/** @ignore */\nexport class Float32Vector extends FloatVector<Float32> {}\n/** @ignore */\nexport class Float64Vector extends FloatVector<Float64> {}\n\nconst convertTo16Bit = (typeCtor: any, dataCtor: any) => {\n    return (typeCtor === Float16) && (dataCtor !== Uint16Array);\n};\n\n/** @ignore */\nconst arrayTypeToDataType = (ctor: FloatArrayCtor) => {\n    switch (ctor) {\n        case Uint16Array:    return Float16;\n        case Float32Array:   return Float32;\n        case Float64Array:   return Float64;\n        default: return null;\n    }\n};\n\n/** @ignore */\nconst vectorTypeToDataType = (ctor: FloatVectorConstructors) => {\n    switch (ctor) {\n        case Float16Vector: return Float16;\n        case Float32Vector: return Float32;\n        case Float64Vector: return Float64;\n        default: return null;\n    }\n};\n"]},"metadata":{},"sourceType":"module"}