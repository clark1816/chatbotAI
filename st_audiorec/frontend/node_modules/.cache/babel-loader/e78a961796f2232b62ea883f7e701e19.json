{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport streamAdapters from './adapters';\n/** @ignore */\n\nexport const ITERATOR_DONE = Object.freeze({\n  done: true,\n  value: void 0\n});\n/** @ignore */\n\nexport class ArrowJSON {\n  // @ts-ignore\n  constructor(_json) {\n    this._json = _json;\n  }\n\n  get schema() {\n    return this._json['schema'];\n  }\n\n  get batches() {\n    return this._json['batches'] || [];\n  }\n\n  get dictionaries() {\n    return this._json['dictionaries'] || [];\n  }\n\n}\n/** @ignore */\n\nexport class ReadableInterop {\n  tee() {\n    return this._getDOMStream().tee();\n  }\n\n  pipe(writable, options) {\n    return this._getNodeStream().pipe(writable, options);\n  }\n\n  pipeTo(writable, options) {\n    return this._getDOMStream().pipeTo(writable, options);\n  }\n\n  pipeThrough(duplex, options) {\n    return this._getDOMStream().pipeThrough(duplex, options);\n  }\n\n  _getDOMStream() {\n    return this._DOMStream || (this._DOMStream = this.toDOMStream());\n  }\n\n  _getNodeStream() {\n    return this._nodeStream || (this._nodeStream = this.toNodeStream());\n  }\n\n}\n/** @ignore */\n\nexport class AsyncQueue extends ReadableInterop {\n  constructor() {\n    super();\n    this._values = [];\n    this.resolvers = [];\n    this._closedPromise = new Promise(r => this._closedPromiseResolve = r);\n  }\n\n  get closed() {\n    return this._closedPromise;\n  }\n\n  async cancel(reason) {\n    await this.return(reason);\n  }\n\n  write(value) {\n    if (this._ensureOpen()) {\n      this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({\n        done: false,\n        value\n      });\n    }\n  }\n\n  abort(value) {\n    if (this._closedPromiseResolve) {\n      this.resolvers.length <= 0 ? this._error = {\n        error: value\n      } : this.resolvers.shift().reject({\n        done: true,\n        value\n      });\n    }\n  }\n\n  close() {\n    if (this._closedPromiseResolve) {\n      const {\n        resolvers\n      } = this;\n\n      while (resolvers.length > 0) {\n        resolvers.shift().resolve(ITERATOR_DONE);\n      }\n\n      this._closedPromiseResolve();\n\n      this._closedPromiseResolve = undefined;\n    }\n  }\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  toDOMStream(options) {\n    return streamAdapters.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);\n  }\n\n  toNodeStream(options) {\n    return streamAdapters.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);\n  }\n\n  async throw(_) {\n    await this.abort(_);\n    return ITERATOR_DONE;\n  }\n\n  async return(_) {\n    await this.close();\n    return ITERATOR_DONE;\n  }\n\n  async read(size) {\n    return (await this.next(size, 'read')).value;\n  }\n\n  async peek(size) {\n    return (await this.next(size, 'peek')).value;\n  }\n\n  next() {\n    if (this._values.length > 0) {\n      return Promise.resolve({\n        done: false,\n        value: this._values.shift()\n      });\n    } else if (this._error) {\n      return Promise.reject({\n        done: true,\n        value: this._error.error\n      });\n    } else if (!this._closedPromiseResolve) {\n      return Promise.resolve(ITERATOR_DONE);\n    } else {\n      return new Promise((resolve, reject) => {\n        this.resolvers.push({\n          resolve,\n          reject\n        });\n      });\n    }\n  }\n\n  _ensureOpen() {\n    if (this._closedPromiseResolve) {\n      return true;\n    }\n\n    throw new Error(`${this} is closed`);\n  }\n\n}","map":{"version":3,"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,cAAP,MAA2B,YAA3B;AAEA;;AACA,OAAO,MAAMC,aAAa,GAAQC,MAAM,CAACC,MAAP,CAAc;AAAEC,MAAI,EAAE,IAAR;AAAcC,OAAK,EAAE,KAAM;AAA3B,CAAd,CAA3B;AASP;;AACA,OAAM,MAAOC,SAAP,CAAgB;AAClB;AACAC,cAAoBC,KAApB,EAAwC;AAApB;AAAwB;;AAC3B,MAANC,MAAM;AAAU,WAAO,KAAKD,KAAL,CAAW,QAAX,CAAP;AAA8B;;AACvC,MAAPE,OAAO;AAAY,WAAQ,KAAKF,KAAL,CAAW,SAAX,KAAyB,EAAjC;AAAgD;;AACvD,MAAZG,YAAY;AAAY,WAAQ,KAAKH,KAAL,CAAW,cAAX,KAA8B,EAAtC;AAAqD;;AALtE;AAoCtB;;AACA,OAAM,MAAgBI,eAAhB,CAA+B;AAK1BC,KAAG;AACN,WAAO,KAAKC,aAAL,GAAqBD,GAArB,EAAP;AACH;;AACME,MAAI,CAAkCC,QAAlC,EAA+CC,OAA/C,EAA2E;AAClF,WAAO,KAAKC,cAAL,GAAsBH,IAAtB,CAA2BC,QAA3B,EAAqCC,OAArC,CAAP;AACH;;AACME,QAAM,CAACH,QAAD,EAA8BC,OAA9B,EAAmD;AAAI,WAAO,KAAKH,aAAL,GAAqBK,MAArB,CAA4BH,QAA5B,EAAsCC,OAAtC,CAAP;AAAwD;;AACrHG,aAAW,CAAgCC,MAAhC,EAAsFJ,OAAtF,EAA2G;AACzH,WAAO,KAAKH,aAAL,GAAqBM,WAArB,CAAiCC,MAAjC,EAAyCJ,OAAzC,CAAP;AACH;;AAGOH,eAAa;AACjB,WAAO,KAAKQ,UAAL,KAAoB,KAAKA,UAAL,GAAkB,KAAKC,WAAL,EAAtC,CAAP;AACH;;AAGOL,gBAAc;AAClB,WAAO,KAAKM,WAAL,KAAqB,KAAKA,WAAL,GAAmB,KAAKC,YAAL,EAAxC,CAAP;AACH;;AAxBgC;AA8BrC;;AACA,OAAM,MAAOC,UAAP,SAAyEd,eAAzE,CAAmG;AASrGL;AACI;AAPM,mBAAuB,EAAvB;AAIA,qBAAqD,EAArD;AAIN,SAAKoB,cAAL,GAAsB,IAAIC,OAAJ,CAAaC,CAAD,IAAO,KAAKC,qBAAL,GAA6BD,CAAhD,CAAtB;AACH;;AAEgB,MAANE,MAAM;AAAoB,WAAO,KAAKJ,cAAZ;AAA6B;;AAC/C,QAANK,MAAM,CAACC,MAAD,EAAa;AAAI,UAAM,KAAKC,MAAL,CAAYD,MAAZ,CAAN;AAA4B;;AACzDE,OAAK,CAAC9B,KAAD,EAAiB;AACzB,QAAI,KAAK+B,WAAL,EAAJ,EAAwB;AACpB,WAAKC,SAAL,CAAeC,MAAf,IAAyB,CAAzB,GACO,KAAKC,OAAL,CAAaC,IAAb,CAAkBnC,KAAlB,CADP,GAEO,KAAKgC,SAAL,CAAeI,KAAf,GAAwBC,OAAxB,CAAgC;AAAEtC,YAAI,EAAE,KAAR;AAAeC;AAAf,OAAhC,CAFP;AAGH;AACJ;;AACMsC,OAAK,CAACtC,KAAD,EAAY;AACpB,QAAI,KAAKyB,qBAAT,EAAgC;AAC5B,WAAKO,SAAL,CAAeC,MAAf,IAAyB,CAAzB,GACO,KAAKM,MAAL,GAAc;AAAEC,aAAK,EAAExC;AAAT,OADrB,GAEO,KAAKgC,SAAL,CAAeI,KAAf,GAAwBK,MAAxB,CAA+B;AAAE1C,YAAI,EAAE,IAAR;AAAcC;AAAd,OAA/B,CAFP;AAGH;AACJ;;AACM0C,OAAK;AACR,QAAI,KAAKjB,qBAAT,EAAgC;AAC5B,YAAM;AAAEO;AAAF,UAAgB,IAAtB;;AACA,aAAOA,SAAS,CAACC,MAAV,GAAmB,CAA1B,EAA6B;AACzBD,iBAAS,CAACI,KAAV,GAAmBC,OAAnB,CAA2BzC,aAA3B;AACH;;AACD,WAAK6B,qBAAL;;AACA,WAAKA,qBAAL,GAA6BkB,SAA7B;AACH;AACJ;;AAE2B,GAApBC,MAAM,CAACC,aAAa,IAAC;AAAK,WAAO,IAAP;AAAc;;AACzC3B,aAAW,CAACN,OAAD,EAAmC;AACjD,WAAOjB,cAAc,CAACuB,WAAf,CACF,KAAKO,qBAAL,IAA8B,KAAKc,MAApC,GACO,IADP,GAEO,KAAKL,OAHT,EAIHtB,OAJG,CAAP;AAKH;;AACMQ,cAAY,CAACR,OAAD,EAA2C;AAC1D,WAAOjB,cAAc,CAACyB,YAAf,CACF,KAAKK,qBAAL,IAA8B,KAAKc,MAApC,GACO,IADP,GAEO,KAAKL,OAHT,EAIHtB,OAJG,CAAP;AAKH;;AACiB,QAALkC,KAAK,CAACC,CAAD,EAAQ;AAAI,UAAM,KAAKT,KAAL,CAAWS,CAAX,CAAN;AAAqB,WAAOnD,aAAP;AAAuB;;AACvD,QAANiC,MAAM,CAACkB,CAAD,EAAQ;AAAI,UAAM,KAAKL,KAAL,EAAN;AAAoB,WAAO9C,aAAP;AAAuB;;AAEzD,QAAJoD,IAAI,CAACC,IAAD,EAAqB;AAA+B,WAAO,CAAC,MAAM,KAAKC,IAAL,CAAUD,IAAV,EAAgB,MAAhB,CAAP,EAAgCjD,KAAvC;AAA+C;;AACnG,QAAJmD,IAAI,CAACF,IAAD,EAAqB;AAA+B,WAAO,CAAC,MAAM,KAAKC,IAAL,CAAUD,IAAV,EAAgB,MAAhB,CAAP,EAAgCjD,KAAvC;AAA+C;;AAC7GkD,MAAI,GAAgB;AACvB,QAAI,KAAKhB,OAAL,CAAaD,MAAb,GAAsB,CAA1B,EAA6B;AACzB,aAAOV,OAAO,CAACc,OAAR,CAAgB;AAAEtC,YAAI,EAAE,KAAR;AAAeC,aAAK,EAAE,KAAKkC,OAAL,CAAaE,KAAb;AAAtB,OAAhB,CAAP;AACH,KAFD,MAEO,IAAI,KAAKG,MAAT,EAAiB;AACpB,aAAOhB,OAAO,CAACkB,MAAR,CAAe;AAAE1C,YAAI,EAAE,IAAR;AAAcC,aAAK,EAAE,KAAKuC,MAAL,CAAYC;AAAjC,OAAf,CAAP;AACH,KAFM,MAEA,IAAI,CAAC,KAAKf,qBAAV,EAAiC;AACpC,aAAOF,OAAO,CAACc,OAAR,CAAgBzC,aAAhB,CAAP;AACH,KAFM,MAEA;AACH,aAAO,IAAI2B,OAAJ,CAAuC,CAACc,OAAD,EAAUI,MAAV,KAAoB;AAC9D,aAAKT,SAAL,CAAeG,IAAf,CAAoB;AAAEE,iBAAF;AAAWI;AAAX,SAApB;AACH,OAFM,CAAP;AAGH;AACJ;;AAESV,aAAW;AACjB,QAAI,KAAKN,qBAAT,EAAgC;AAC5B,aAAO,IAAP;AACH;;AACD,UAAM,IAAI2B,KAAJ,CAAU,GAAG,IAAI,YAAjB,CAAN;AACH;;AAhFoG","names":["streamAdapters","ITERATOR_DONE","Object","freeze","done","value","ArrowJSON","constructor","_json","schema","batches","dictionaries","ReadableInterop","tee","_getDOMStream","pipe","writable","options","_getNodeStream","pipeTo","pipeThrough","duplex","_DOMStream","toDOMStream","_nodeStream","toNodeStream","AsyncQueue","_closedPromise","Promise","r","_closedPromiseResolve","closed","cancel","reason","return","write","_ensureOpen","resolvers","length","_values","push","shift","resolve","abort","_error","error","reject","close","undefined","Symbol","asyncIterator","throw","_","read","size","next","peek","Error"],"sources":["io/interfaces.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport streamAdapters from './adapters';\n\n/** @ignore */\nexport const ITERATOR_DONE: any = Object.freeze({ done: true, value: void (0) });\n\n/** @ignore */\nexport type FileHandle = import('fs').promises.FileHandle;\n/** @ignore */\nexport type ArrowJSONLike = { schema: any; batches?: any[]; dictionaries?: any[]; };\n/** @ignore */\nexport type ReadableDOMStreamOptions = { type: 'bytes' | undefined, autoAllocateChunkSize?: number, highWaterMark?: number };\n\n/** @ignore */\nexport class ArrowJSON {\n    // @ts-ignore\n    constructor(private _json: ArrowJSONLike) {}\n    public get schema(): any { return this._json['schema']; }\n    public get batches(): any[] { return (this._json['batches'] || []) as any[]; }\n    public get dictionaries(): any[] { return (this._json['dictionaries'] || []) as any[]; }\n}\n\n/** @ignore */\nexport interface Readable<T> {\n\n    readonly closed: Promise<void>;\n    cancel(reason?: any): Promise<void>;\n\n    read(size?: number | null): Promise<T | null>;\n    peek(size?: number | null): Promise<T | null>;\n    throw(value?: any): Promise<IteratorResult<any>>;\n    return(value?: any): Promise<IteratorResult<any>>;\n    next(size?: number | null): Promise<IteratorResult<T>>;\n}\n\n/** @ignore */\nexport interface Writable<T> {\n    readonly closed: Promise<void>;\n    close(): void;\n    write(chunk: T): void;\n    abort(reason?: any): void;\n}\n\n/** @ignore */\nexport interface ReadableWritable<TReadable, TWritable> extends Readable<TReadable>, Writable<TWritable> {\n    [Symbol.asyncIterator](): AsyncIterableIterator<TReadable>;\n    toDOMStream(options?: ReadableDOMStreamOptions): ReadableStream<TReadable>;\n    toNodeStream(options?: import('stream').ReadableOptions): import('stream').Readable;\n}\n\n/** @ignore */\nexport abstract class ReadableInterop<T> {\n\n    public abstract toDOMStream(options?: ReadableDOMStreamOptions): ReadableStream<T>;\n    public abstract toNodeStream(options?: import('stream').ReadableOptions): import('stream').Readable;\n\n    public tee(): [ReadableStream<T>, ReadableStream<T>] {\n        return this._getDOMStream().tee();\n    }\n    public pipe<R extends NodeJS.WritableStream>(writable: R, options?: { end?: boolean; }) {\n        return this._getNodeStream().pipe(writable, options);\n    }\n    public pipeTo(writable: WritableStream<T>, options?: PipeOptions) { return this._getDOMStream().pipeTo(writable, options); }\n    public pipeThrough<R extends ReadableStream<any>>(duplex: { writable: WritableStream<T>, readable: R }, options?: PipeOptions) {\n        return this._getDOMStream().pipeThrough(duplex, options);\n    }\n\n    protected _DOMStream?: ReadableStream<T>;\n    private _getDOMStream() {\n        return this._DOMStream || (this._DOMStream = this.toDOMStream());\n    }\n\n    protected _nodeStream?: import('stream').Readable;\n    private _getNodeStream() {\n        return this._nodeStream || (this._nodeStream = this.toNodeStream());\n    }\n}\n\n/** @ignore */\ntype Resolution<T> = { resolve: (value?: T | PromiseLike<T>) => void; reject: (reason?: any) => void; };\n\n/** @ignore */\nexport class AsyncQueue<TReadable = Uint8Array, TWritable = TReadable> extends ReadableInterop<TReadable>\n    implements AsyncIterableIterator<TReadable>, ReadableWritable<TReadable, TWritable> {\n\n    protected _values: TWritable[] = [];\n    protected _error?: { error: any; };\n    protected _closedPromise: Promise<void>;\n    protected _closedPromiseResolve?: (value?: any) => void;\n    protected resolvers: Resolution<IteratorResult<TReadable>>[] = [];\n\n    constructor() {\n        super();\n        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);\n    }\n\n    public get closed(): Promise<void> { return this._closedPromise; }\n    public async cancel(reason?: any) { await this.return(reason); }\n    public write(value: TWritable) {\n        if (this._ensureOpen()) {\n            this.resolvers.length <= 0\n                ? (this._values.push(value))\n                : (this.resolvers.shift()!.resolve({ done: false, value } as any));\n        }\n    }\n    public abort(value?: any) {\n        if (this._closedPromiseResolve) {\n            this.resolvers.length <= 0\n                ? (this._error = { error: value })\n                : (this.resolvers.shift()!.reject({ done: true, value }));\n        }\n    }\n    public close() {\n        if (this._closedPromiseResolve) {\n            const { resolvers } = this;\n            while (resolvers.length > 0) {\n                resolvers.shift()!.resolve(ITERATOR_DONE);\n            }\n            this._closedPromiseResolve();\n            this._closedPromiseResolve = undefined;\n        }\n    }\n\n    public [Symbol.asyncIterator]() { return this; }\n    public toDOMStream(options?: ReadableDOMStreamOptions) {\n        return streamAdapters.toDOMStream(\n            (this._closedPromiseResolve || this._error)\n                ? (this as AsyncIterable<TReadable>)\n                : (this._values as any) as Iterable<TReadable>,\n            options);\n    }\n    public toNodeStream(options?: import('stream').ReadableOptions) {\n        return streamAdapters.toNodeStream(\n            (this._closedPromiseResolve || this._error)\n                ? (this as AsyncIterable<TReadable>)\n                : (this._values as any) as Iterable<TReadable>,\n            options);\n    }\n    public async throw(_?: any) { await this.abort(_); return ITERATOR_DONE; }\n    public async return(_?: any) { await this.close(); return ITERATOR_DONE; }\n\n    public async read(size?: number | null): Promise<TReadable | null> { return (await this.next(size, 'read')).value; }\n    public async peek(size?: number | null): Promise<TReadable | null> { return (await this.next(size, 'peek')).value; }\n    public next(..._args: any[]): Promise<IteratorResult<TReadable>> {\n        if (this._values.length > 0) {\n            return Promise.resolve({ done: false, value: this._values.shift()! } as any);\n        } else if (this._error) {\n            return Promise.reject({ done: true, value: this._error.error });\n        } else if (!this._closedPromiseResolve) {\n            return Promise.resolve(ITERATOR_DONE);\n        } else {\n            return new Promise<IteratorResult<TReadable>>((resolve, reject) => {\n                this.resolvers.push({ resolve, reject });\n            });\n        }\n    }\n\n    protected _ensureOpen() {\n        if (this._closedPromiseResolve) {\n            return true;\n        }\n        throw new Error(`${this} is closed`);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}