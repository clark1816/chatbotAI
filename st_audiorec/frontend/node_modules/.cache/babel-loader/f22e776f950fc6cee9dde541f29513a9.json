{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { MessageHeader } from '../enum';\nimport { flatbuffers } from 'flatbuffers';\nvar ByteBuffer = flatbuffers.ByteBuffer;\nimport { Message } from './metadata/message';\nimport { isFileHandle } from '../util/compat';\nimport { AsyncRandomAccessFile } from '../io/file';\nimport { toUint8Array } from '../util/buffer';\nimport { ByteStream, AsyncByteStream } from '../io/stream';\nimport { ArrowJSON, ITERATOR_DONE } from '../io/interfaces';\n/** @ignore */\n\nconst invalidMessageType = type => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;\n/** @ignore */\n\n\nconst nullMessage = type => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;\n/** @ignore */\n\n\nconst invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n/** @ignore */\n\n\nconst invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n/** @ignore */\n\n\nexport class MessageReader {\n  constructor(source) {\n    this.source = source instanceof ByteStream ? source : new ByteStream(source);\n  }\n\n  [Symbol.iterator]() {\n    return this;\n  }\n\n  next() {\n    let r;\n\n    if ((r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    } // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n    // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n    // pre-v0.15 message, where the first 4 bytes are the metadata length.\n\n\n    if (r.value === -1 && (r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n\n    if ((r = this.readMetadata(r.value)).done) {\n      return ITERATOR_DONE;\n    }\n\n    return r;\n  }\n\n  throw(value) {\n    return this.source.throw(value);\n  }\n\n  return(value) {\n    return this.source.return(value);\n  }\n\n  readMessage(type) {\n    let r;\n\n    if ((r = this.next()).done) {\n      return null;\n    }\n\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n\n    return r.value;\n  }\n\n  readMessageBody(bodyLength) {\n    if (bodyLength <= 0) {\n      return new Uint8Array(0);\n    }\n\n    const buf = toUint8Array(this.source.read(bodyLength));\n\n    if (buf.byteLength < bodyLength) {\n      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n    } // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n    // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n\n\n    return (\n      /* 1. */\n      buf.byteOffset % 8 === 0 &&\n      /* 2. */\n      buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n    );\n  }\n\n  readSchema() {\n    let throwIfNull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const type = MessageHeader.Schema;\n    const message = this.readMessage(type);\n    const schema = message && message.header();\n\n    if (throwIfNull && !schema) {\n      throw new Error(nullMessage(type));\n    }\n\n    return schema;\n  }\n\n  readMetadataLength() {\n    const buf = this.source.read(PADDING);\n    const bb = buf && new ByteBuffer(buf);\n    const len = bb && bb.readInt32(0) || 0;\n    return {\n      done: len === 0,\n      value: len\n    };\n  }\n\n  readMetadata(metadataLength) {\n    const buf = this.source.read(metadataLength);\n\n    if (!buf) {\n      return ITERATOR_DONE;\n    }\n\n    if (buf.byteLength < metadataLength) {\n      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n    }\n\n    return {\n      done: false,\n      value: Message.decode(buf)\n    };\n  }\n\n}\n/** @ignore */\n\nexport class AsyncMessageReader {\n  constructor(source, byteLength) {\n    this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);\n  }\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  async next() {\n    let r;\n\n    if ((r = await this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    } // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n    // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n    // pre-v0.15 message, where the first 4 bytes are the metadata length.\n\n\n    if (r.value === -1 && (r = await this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n\n    if ((r = await this.readMetadata(r.value)).done) {\n      return ITERATOR_DONE;\n    }\n\n    return r;\n  }\n\n  async throw(value) {\n    return await this.source.throw(value);\n  }\n\n  async return(value) {\n    return await this.source.return(value);\n  }\n\n  async readMessage(type) {\n    let r;\n\n    if ((r = await this.next()).done) {\n      return null;\n    }\n\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n\n    return r.value;\n  }\n\n  async readMessageBody(bodyLength) {\n    if (bodyLength <= 0) {\n      return new Uint8Array(0);\n    }\n\n    const buf = toUint8Array(await this.source.read(bodyLength));\n\n    if (buf.byteLength < bodyLength) {\n      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n    } // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n    // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n\n\n    return (\n      /* 1. */\n      buf.byteOffset % 8 === 0 &&\n      /* 2. */\n      buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n    );\n  }\n\n  async readSchema() {\n    let throwIfNull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const type = MessageHeader.Schema;\n    const message = await this.readMessage(type);\n    const schema = message && message.header();\n\n    if (throwIfNull && !schema) {\n      throw new Error(nullMessage(type));\n    }\n\n    return schema;\n  }\n\n  async readMetadataLength() {\n    const buf = await this.source.read(PADDING);\n    const bb = buf && new ByteBuffer(buf);\n    const len = bb && bb.readInt32(0) || 0;\n    return {\n      done: len === 0,\n      value: len\n    };\n  }\n\n  async readMetadata(metadataLength) {\n    const buf = await this.source.read(metadataLength);\n\n    if (!buf) {\n      return ITERATOR_DONE;\n    }\n\n    if (buf.byteLength < metadataLength) {\n      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n    }\n\n    return {\n      done: false,\n      value: Message.decode(buf)\n    };\n  }\n\n}\n/** @ignore */\n\nexport class JSONMessageReader extends MessageReader {\n  constructor(source) {\n    super(new Uint8Array(0));\n    this._schema = false;\n    this._body = [];\n    this._batchIndex = 0;\n    this._dictionaryIndex = 0;\n    this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n  }\n\n  next() {\n    const {\n      _json\n    } = this;\n\n    if (!this._schema) {\n      this._schema = true;\n      const message = Message.fromJSON(_json.schema, MessageHeader.Schema);\n      return {\n        done: false,\n        value: message\n      };\n    }\n\n    if (this._dictionaryIndex < _json.dictionaries.length) {\n      const batch = _json.dictionaries[this._dictionaryIndex++];\n      this._body = batch['data']['columns'];\n      const message = Message.fromJSON(batch, MessageHeader.DictionaryBatch);\n      return {\n        done: false,\n        value: message\n      };\n    }\n\n    if (this._batchIndex < _json.batches.length) {\n      const batch = _json.batches[this._batchIndex++];\n      this._body = batch['columns'];\n      const message = Message.fromJSON(batch, MessageHeader.RecordBatch);\n      return {\n        done: false,\n        value: message\n      };\n    }\n\n    this._body = [];\n    return ITERATOR_DONE;\n  }\n\n  readMessageBody(_bodyLength) {\n    return flattenDataSources(this._body);\n\n    function flattenDataSources(xs) {\n      return (xs || []).reduce((buffers, column) => [...buffers, ...(column['VALIDITY'] && [column['VALIDITY']] || []), ...(column['TYPE'] && [column['TYPE']] || []), ...(column['OFFSET'] && [column['OFFSET']] || []), ...(column['DATA'] && [column['DATA']] || []), ...flattenDataSources(column['children'])], []);\n    }\n  }\n\n  readMessage(type) {\n    let r;\n\n    if ((r = this.next()).done) {\n      return null;\n    }\n\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n\n    return r.value;\n  }\n\n  readSchema() {\n    const type = MessageHeader.Schema;\n    const message = this.readMessage(type);\n    const schema = message && message.header();\n\n    if (!message || !schema) {\n      throw new Error(nullMessage(type));\n    }\n\n    return schema;\n  }\n\n}\n/** @ignore */\n\nexport const PADDING = 4;\n/** @ignore */\n\nexport const MAGIC_STR = 'ARROW1';\n/** @ignore */\n\nexport const MAGIC = new Uint8Array(MAGIC_STR.length);\n\nfor (let i = 0; i < MAGIC_STR.length; i += 1 | 0) {\n  MAGIC[i] = MAGIC_STR.charCodeAt(i);\n}\n/** @ignore */\n\n\nexport function checkForMagicArrowString(buffer) {\n  let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  for (let i = -1, n = MAGIC.length; ++i < n;) {\n    if (MAGIC[i] !== buffer[index + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/** @ignore */\n\nexport const magicLength = MAGIC.length;\n/** @ignore */\n\nexport const magicAndPadding = magicLength + PADDING;\n/** @ignore */\n\nexport const magicX2AndPadding = magicLength * 2 + PADDING;","map":{"version":3,"mappings":"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","names":["MessageHeader","flatbuffers","ByteBuffer","Message","isFileHandle","AsyncRandomAccessFile","toUint8Array","ByteStream","AsyncByteStream","ArrowJSON","ITERATOR_DONE","invalidMessageType","type","nullMessage","invalidMessageMetadata","expected","actual","invalidMessageBodyLength","MessageReader","constructor","source","Symbol","iterator","next","r","readMetadataLength","done","value","readMetadata","throw","return","readMessage","headerType","Error","readMessageBody","bodyLength","Uint8Array","buf","read","byteLength","byteOffset","buffer","slice","readSchema","throwIfNull","Schema","message","schema","header","PADDING","bb","len","readInt32","metadataLength","decode","AsyncMessageReader","asyncIterator","JSONMessageReader","_json","_schema","fromJSON","_dictionaryIndex","dictionaries","length","batch","_body","DictionaryBatch","_batchIndex","batches","RecordBatch","_bodyLength","flattenDataSources","xs","reduce","buffers","column","MAGIC_STR","MAGIC","i","charCodeAt","checkForMagicArrowString","index","n","magicLength","magicAndPadding","magicX2AndPadding"],"sources":["ipc/message.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { MessageHeader } from '../enum';\nimport { flatbuffers } from 'flatbuffers';\nimport ByteBuffer = flatbuffers.ByteBuffer;\nimport { Message } from './metadata/message';\nimport { isFileHandle } from '../util/compat';\nimport { AsyncRandomAccessFile } from '../io/file';\nimport { toUint8Array, ArrayBufferViewInput } from '../util/buffer';\nimport { ByteStream, ReadableSource, AsyncByteStream } from '../io/stream';\nimport { ArrowJSON, ArrowJSONLike, ITERATOR_DONE, FileHandle } from '../io/interfaces';\n\n/** @ignore */ const invalidMessageType       = (type: MessageHeader) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;\n/** @ignore */ const nullMessage              = (type: MessageHeader) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;\n/** @ignore */ const invalidMessageMetadata   = (expected: number, actual: number) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n/** @ignore */ const invalidMessageBodyLength = (expected: number, actual: number) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n\n/** @ignore */\nexport class MessageReader implements IterableIterator<Message> {\n    protected source: ByteStream;\n    constructor(source: ByteStream | ArrayBufferViewInput | Iterable<ArrayBufferViewInput>) {\n        this.source = source instanceof ByteStream ? source : new ByteStream(source);\n    }\n    public [Symbol.iterator](): IterableIterator<Message> { return this as IterableIterator<Message>; }\n    public next(): IteratorResult<Message> {\n        let r;\n        if ((r = this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n        // pre-v0.15 message, where the first 4 bytes are the metadata length.\n        if ((r.value === -1) &&\n            (r = this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        if ((r = this.readMetadata(r.value)).done) { return ITERATOR_DONE; }\n        return (<any> r) as IteratorResult<Message>;\n    }\n    public throw(value?: any) { return this.source.throw(value); }\n    public return(value?: any) { return this.source.return(value); }\n    public readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public readMessageBody(bodyLength: number): Uint8Array {\n        if (bodyLength <= 0) { return new Uint8Array(0); }\n        const buf = toUint8Array(this.source.read(bodyLength));\n        if (buf.byteLength < bodyLength) {\n            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n        }\n        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n        return /* 1. */ (buf.byteOffset % 8 === 0) &&\n               /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();\n    }\n    public readSchema(throwIfNull = false) {\n        const type = MessageHeader.Schema;\n        const message = this.readMessage(type);\n        const schema = message && message.header();\n        if (throwIfNull && !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n    protected readMetadataLength(): IteratorResult<number> {\n        const buf = this.source.read(PADDING);\n        const bb = buf && new ByteBuffer(buf);\n        const len = bb && bb.readInt32(0) || 0;\n        return { done: len === 0, value: len };\n    }\n    protected readMetadata(metadataLength: number): IteratorResult<Message> {\n        const buf = this.source.read(metadataLength);\n        if (!buf) { return ITERATOR_DONE; }\n        if (buf.byteLength < metadataLength) {\n            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n        }\n        return { done: false, value: Message.decode(buf) };\n    }\n}\n\n/** @ignore */\nexport class AsyncMessageReader implements AsyncIterableIterator<Message> {\n    protected source: AsyncByteStream;\n    constructor(source: ReadableSource<Uint8Array>);\n    constructor(source: FileHandle, byteLength?: number);\n    constructor(source: any, byteLength?: number) {\n        this.source = source instanceof AsyncByteStream ? source\n            : isFileHandle(source)\n            ? new AsyncRandomAccessFile(source, byteLength!)\n            : new AsyncByteStream(source);\n    }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<Message> { return this as AsyncIterableIterator<Message>; }\n    public async next(): Promise<IteratorResult<Message>> {\n        let r;\n        if ((r = await this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n        // pre-v0.15 message, where the first 4 bytes are the metadata length.\n        if ((r.value === -1) &&\n            (r = await this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        if ((r = await this.readMetadata(r.value)).done) { return ITERATOR_DONE; }\n        return (<any> r) as IteratorResult<Message>;\n    }\n    public async throw(value?: any) { return await this.source.throw(value); }\n    public async return(value?: any) { return await this.source.return(value); }\n    public async readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = await this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public async readMessageBody(bodyLength: number): Promise<Uint8Array> {\n        if (bodyLength <= 0) { return new Uint8Array(0); }\n        const buf = toUint8Array(await this.source.read(bodyLength));\n        if (buf.byteLength < bodyLength) {\n            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n        }\n        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n        return /* 1. */ (buf.byteOffset % 8 === 0) &&\n               /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();\n    }\n    public async readSchema(throwIfNull = false) {\n        const type = MessageHeader.Schema;\n        const message = await this.readMessage(type);\n        const schema = message && message.header();\n        if (throwIfNull && !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n    protected async readMetadataLength(): Promise<IteratorResult<number>> {\n        const buf = await this.source.read(PADDING);\n        const bb = buf && new ByteBuffer(buf);\n        const len = bb && bb.readInt32(0) || 0;\n        return { done: len === 0, value: len };\n    }\n    protected async readMetadata(metadataLength: number): Promise<IteratorResult<Message>> {\n        const buf = await this.source.read(metadataLength);\n        if (!buf) { return ITERATOR_DONE; }\n        if (buf.byteLength < metadataLength) {\n            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n        }\n        return { done: false, value: Message.decode(buf) };\n    }\n}\n\n/** @ignore */\nexport class JSONMessageReader extends MessageReader {\n    private _schema = false;\n    private _json: ArrowJSON;\n    private _body: any[] = [];\n    private _batchIndex = 0;\n    private _dictionaryIndex = 0;\n    constructor(source: ArrowJSON | ArrowJSONLike) {\n        super(new Uint8Array(0));\n        this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n    }\n    public next() {\n        const { _json } = this;\n        if (!this._schema) {\n            this._schema = true;\n            const message = Message.fromJSON(_json.schema, MessageHeader.Schema);\n            return { done: false, value: message };\n        }\n        if (this._dictionaryIndex < _json.dictionaries.length) {\n            const batch = _json.dictionaries[this._dictionaryIndex++];\n            this._body = batch['data']['columns'];\n            const message = Message.fromJSON(batch, MessageHeader.DictionaryBatch);\n            return { done: false, value: message };\n        }\n        if (this._batchIndex < _json.batches.length) {\n            const batch = _json.batches[this._batchIndex++];\n            this._body = batch['columns'];\n            const message = Message.fromJSON(batch, MessageHeader.RecordBatch);\n            return { done: false, value: message };\n        }\n        this._body = [];\n        return ITERATOR_DONE;\n    }\n    public readMessageBody(_bodyLength?: number) {\n        return flattenDataSources(this._body) as any;\n        function flattenDataSources(xs: any[]): any[][] {\n            return (xs || []).reduce<any[][]>((buffers, column: any) => [\n                ...buffers,\n                ...(column['VALIDITY'] && [column['VALIDITY']] || []),\n                ...(column['TYPE'] && [column['TYPE']] || []),\n                ...(column['OFFSET'] && [column['OFFSET']] || []),\n                ...(column['DATA'] && [column['DATA']] || []),\n                ...flattenDataSources(column['children'])\n            ], [] as any[][]);\n        }\n    }\n    public readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public readSchema() {\n        const type = MessageHeader.Schema;\n        const message = this.readMessage(type);\n        const schema = message && message.header();\n        if (!message || !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n}\n\n/** @ignore */\nexport const PADDING = 4;\n/** @ignore */\nexport const MAGIC_STR = 'ARROW1';\n/** @ignore */\nexport const MAGIC = new Uint8Array(MAGIC_STR.length);\n\nfor (let i = 0; i < MAGIC_STR.length; i += 1 | 0) {\n    MAGIC[i] = MAGIC_STR.charCodeAt(i);\n}\n\n/** @ignore */\nexport function checkForMagicArrowString(buffer: Uint8Array, index = 0) {\n    for (let i = -1, n = MAGIC.length; ++i < n;) {\n        if (MAGIC[i] !== buffer[index + i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/** @ignore */\nexport const magicLength = MAGIC.length;\n/** @ignore */\nexport const magicAndPadding = magicLength + PADDING;\n/** @ignore */\nexport const magicX2AndPadding = magicLength * 2 + PADDING;\n"]},"metadata":{},"sourceType":"module"}