{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Builder } from '../../builder/index';\n/** @ignore */\n\nexport function builderThroughDOMStream(options) {\n  return new BuilderTransform(options);\n}\n/** @ignore */\n\nexport class BuilderTransform {\n  constructor(options) {\n    // Access properties by string indexers to defeat closure compiler\n    this._numChunks = 0;\n    this._finished = false;\n    this._bufferedSize = 0;\n    const {\n      ['readableStrategy']: readableStrategy,\n      ['writableStrategy']: writableStrategy,\n      ['queueingStrategy']: queueingStrategy = 'count',\n      ...builderOptions\n    } = options;\n    this._controller = null;\n    this._builder = Builder.new(builderOptions);\n    this._getSize = queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength;\n    const {\n      ['highWaterMark']: readableHighWaterMark = queueingStrategy === 'bytes' ? 2 ** 14 : 1000\n    } = { ...readableStrategy\n    };\n    const {\n      ['highWaterMark']: writableHighWaterMark = queueingStrategy === 'bytes' ? 2 ** 14 : 1000\n    } = { ...writableStrategy\n    };\n    this['readable'] = new ReadableStream({\n      ['cancel']: () => {\n        this._builder.clear();\n      },\n      ['pull']: c => {\n        this._maybeFlush(this._builder, this._controller = c);\n      },\n      ['start']: c => {\n        this._maybeFlush(this._builder, this._controller = c);\n      }\n    }, {\n      'highWaterMark': readableHighWaterMark,\n      'size': queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength\n    });\n    this['writable'] = new WritableStream({\n      ['abort']: () => {\n        this._builder.clear();\n      },\n      ['write']: () => {\n        this._maybeFlush(this._builder, this._controller);\n      },\n      ['close']: () => {\n        this._maybeFlush(this._builder.finish(), this._controller);\n      }\n    }, {\n      'highWaterMark': writableHighWaterMark,\n      'size': value => this._writeValueAndReturnChunkSize(value)\n    });\n  }\n\n  _writeValueAndReturnChunkSize(value) {\n    const bufferedSize = this._bufferedSize;\n    this._bufferedSize = this._getSize(this._builder.append(value));\n    return this._bufferedSize - bufferedSize;\n  }\n\n  _maybeFlush(builder, controller) {\n    if (controller === null) {\n      return;\n    }\n\n    if (this._bufferedSize >= controller.desiredSize) {\n      ++this._numChunks && this._enqueue(controller, builder.toVector());\n    }\n\n    if (builder.finished) {\n      if (builder.length > 0 || this._numChunks === 0) {\n        ++this._numChunks && this._enqueue(controller, builder.toVector());\n      }\n\n      if (!this._finished && (this._finished = true)) {\n        this._enqueue(controller, null);\n      }\n    }\n  }\n\n  _enqueue(controller, chunk) {\n    this._bufferedSize = 0;\n    this._controller = null;\n    chunk === null ? controller.close() : controller.enqueue(chunk);\n  }\n\n}\n/** @ignore */\n\nconst chunkLength = chunk => chunk.length;\n/** @ignore */\n\n\nconst chunkByteLength = chunk => chunk.byteLength;","map":{"version":3,"mappings":"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","names":["Builder","builderThroughDOMStream","options","BuilderTransform","constructor","readableStrategy","writableStrategy","queueingStrategy","builderOptions","_controller","_builder","new","_getSize","chunkLength","chunkByteLength","readableHighWaterMark","writableHighWaterMark","ReadableStream","clear","c","_maybeFlush","WritableStream","finish","value","_writeValueAndReturnChunkSize","bufferedSize","_bufferedSize","append","builder","controller","desiredSize","_numChunks","_enqueue","toVector","finished","length","_finished","chunk","close","enqueue","byteLength"],"sources":["io/whatwg/builder.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { DataType } from '../../type';\nimport { Vector } from '../../vector';\nimport { VectorType as V } from '../../interfaces';\nimport { Builder, BuilderOptions } from '../../builder/index';\n\n/** @ignore */\nexport interface BuilderTransformOptions<T extends DataType = any, TNull = any> extends BuilderOptions<T, TNull> {\n    queueingStrategy?: 'bytes' | 'count';\n    dictionaryHashFunction?: (value: any) => string | number;\n    readableStrategy?: { highWaterMark?: number, size?: any, type?: 'bytes'; };\n    writableStrategy?: { highWaterMark?: number, size?: any, type?: 'bytes'; };\n    valueToChildTypeId?: (builder: Builder<T, TNull>, value: any, offset: number) => number;\n}\n\n/** @ignore */\nexport function builderThroughDOMStream<T extends DataType = any, TNull = any>(options: BuilderTransformOptions<T, TNull>) {\n    return new BuilderTransform(options);\n}\n\n/** @ignore */\nexport class BuilderTransform<T extends DataType = any, TNull = any> {\n\n    public readable: ReadableStream<V<T>>;\n    public writable: WritableStream<T['TValue'] | TNull>;\n    public _controller: ReadableStreamDefaultController<V<T>> | null;\n\n    private _numChunks = 0;\n    private _finished = false;\n    private _bufferedSize = 0;\n    private _builder: Builder<T, TNull>;\n    private _getSize: (builder: Builder<T, TNull>) => number;\n\n    constructor(options: BuilderTransformOptions<T, TNull>) {\n\n        // Access properties by string indexers to defeat closure compiler\n\n        const {\n            ['readableStrategy']: readableStrategy,\n            ['writableStrategy']: writableStrategy,\n            ['queueingStrategy']: queueingStrategy = 'count',\n            ...builderOptions\n        } = options;\n\n        this._controller = null;\n        this._builder = Builder.new<T, TNull>(builderOptions);\n        this._getSize = queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength;\n\n        const { ['highWaterMark']: readableHighWaterMark = queueingStrategy === 'bytes' ? 2 ** 14 : 1000 } = { ...readableStrategy };\n        const { ['highWaterMark']: writableHighWaterMark = queueingStrategy === 'bytes' ? 2 ** 14 : 1000 } = { ...writableStrategy };\n\n        this['readable'] = new ReadableStream<V<T>>({\n            ['cancel']: ()  => { this._builder.clear(); },\n            ['pull']: (c) => { this._maybeFlush(this._builder, this._controller = c); },\n            ['start']: (c) => { this._maybeFlush(this._builder, this._controller = c); },\n        }, {\n            'highWaterMark': readableHighWaterMark,\n            'size': queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength,\n        });\n\n        this['writable'] = new WritableStream({\n            ['abort']: () => { this._builder.clear(); },\n            ['write']: () => { this._maybeFlush(this._builder, this._controller); },\n            ['close']: () => { this._maybeFlush(this._builder.finish(), this._controller); },\n        }, {\n            'highWaterMark': writableHighWaterMark,\n            'size': (value: T['TValue'] | TNull) => this._writeValueAndReturnChunkSize(value),\n        });\n    }\n\n    private _writeValueAndReturnChunkSize(value: T['TValue'] | TNull) {\n        const bufferedSize = this._bufferedSize;\n        this._bufferedSize = this._getSize(this._builder.append(value));\n        return this._bufferedSize - bufferedSize;\n    }\n\n    private _maybeFlush(builder: Builder<T, TNull>, controller: ReadableStreamDefaultController<V<T>> | null) {\n        if (controller === null) { return; }\n        if (this._bufferedSize >= controller.desiredSize!) {\n            ++this._numChunks && this._enqueue(controller, builder.toVector());\n        }\n        if (builder.finished) {\n            if (builder.length > 0 || this._numChunks === 0) {\n                ++this._numChunks && this._enqueue(controller, builder.toVector());\n            }\n            if (!this._finished && (this._finished = true)) {\n                this._enqueue(controller, null);\n            }\n        }\n    }\n\n    private _enqueue(controller: ReadableStreamDefaultController<V<T>>, chunk: V<T> | null) {\n        this._bufferedSize = 0;\n        this._controller = null;\n        chunk === null ? controller.close() : controller.enqueue(chunk);\n    }\n}\n\n/** @ignore */ const chunkLength = <T extends DataType = any>(chunk: Vector<T> | Builder<T>) => chunk.length;\n/** @ignore */ const chunkByteLength = <T extends DataType = any>(chunk: Vector<T> | Builder<T>) => chunk.byteLength;\n"]},"metadata":{},"sourceType":"module"}